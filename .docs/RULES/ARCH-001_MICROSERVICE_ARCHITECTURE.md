# 微服务架构设计规则

## 📋 规则概述

**ID**: ARCH-001  
**Name**: 微服务架构设计规则  
**Status**: Active  
**创建时间**: 2025-08-04  

## 🎯 核心原则

### 1. 架构分层原则
- **服务层 (service/)**: 基础服务和业务服务
- **核心层 (core/)**: 核心业务模块
- **第三方层 (third-party/)**: 第三方服务集成
- **基础设施层 (zinfra/)**: 数据库、配置、文档

### 2. 模块职责分离
- **service-base**: 基础依赖和配置管理
- **service-common**: 通用组件和工具类
- **service-auth**: 认证和授权服务
- **service-user**: 用户管理服务
- **service-gateway**: API网关服务
- **core-publisher**: 核心业务发布者服务
- **aliyun-oss**: 第三方OSS服务

### 3. 依赖管理原则
- **单向依赖**: 避免循环依赖
- **分层依赖**: 上层依赖下层，同层不依赖
- **最小依赖**: 只依赖必要的模块

## 🏗️ 架构设计规范

### 1. 服务拆分原则
- **单一职责**: 每个服务只负责一个业务领域
- **高内聚**: 相关功能聚合在同一服务
- **低耦合**: 服务间通过标准接口通信
- **可独立部署**: 每个服务可独立开发、测试、部署

### 2. 模块组织规范
```
banyuMall (父项目)
├── service/ (服务层)
│   ├── service-base/ (基础依赖)
│   ├── service-common/ (通用组件)
│   ├── service-auth/ (认证服务)
│   ├── service-user/ (用户服务)
│   └── service-gateway/ (API网关)
├── core/ (核心业务层)
│   └── core-publisher/ (发布者服务)
└── third-party/ (第三方服务层)
    └── aliyun-oss/ (OSS服务)
```

### 3. 端口分配规范
| 服务 | 端口 | 说明 |
|------|------|------|
| service-gateway | 8080 | API网关 |
| service-auth | 8081 | 认证服务 |
| service-user | 8082 | 用户服务 |
| core-publisher | 8084 | 发布者服务 |
| aliyun-oss | 8085 | OSS服务 |

## 🔗 服务通信规范

### 1. 服务间调用
- **同步调用**: 使用 OpenFeign 进行服务间调用
- **异步通信**: 使用消息队列（待实现）
- **服务发现**: 使用 Nacos 进行服务注册与发现
- **负载均衡**: 使用 Spring Cloud LoadBalancer

### 2. 接口设计原则
- **RESTful API**: 遵循 REST 设计原则
- **统一响应格式**: 使用 `ResultData` 统一响应
- **版本控制**: API 版本管理（待实现）
- **文档化**: 使用 Knife4j 自动生成 API 文档

### 3. Feign客户端设计原则
- **公共类统一管理**: Feign客户端使用的公共DTO类必须放在 `service-common` 模块中
- **避免重复定义**: 禁止在多个模块中重复定义相同的DTO类
- **统一import路径**: 所有模块必须使用 `com.origin.common.dto.*` 路径导入公共DTO类
- **版本一致性**: 确保所有模块使用相同版本的公共DTO类
- **依赖关系明确**: 使用Feign客户端的模块必须依赖 `service-common` 模块

### 4. 错误处理
- **全局异常处理**: 统一异常处理机制
- **服务降级**: 使用 Hystrix 进行服务降级
- **熔断机制**: 防止服务雪崩
- **重试机制**: 网络异常自动重试

## 📦 依赖管理规范

### 1. 依赖层次结构
```
service-gateway
    ↓ (依赖)
service-common
    ↓ (依赖)
service-base

service-auth
    ↓ (依赖)
service-common

service-user
    ↓ (依赖)
service-common

core-publisher
    ↓ (依赖)
service-common, service-base

aliyun-oss
    ↓ (依赖)
service-common
```

### 2. 依赖版本管理
- **统一版本**: 在父项目 `pom.xml` 中统一管理版本
- **BOM管理**: 使用 Spring Cloud BOM 管理依赖版本
- **版本锁定**: 避免依赖版本冲突
- **定期更新**: 定期更新依赖版本

### 3. 依赖排除原则
- **排除冲突**: 排除冲突的依赖
- **最小依赖**: 只引入必要的依赖
- **传递依赖**: 控制传递依赖的影响范围

## 🔧 配置管理规范

### 1. 配置分离原则
- **环境分离**: 开发、测试、生产环境配置分离
- **敏感信息**: 敏感配置使用环境变量或配置中心
- **动态配置**: 使用 Nacos 进行动态配置管理
- **配置加密**: 敏感配置进行加密处理

### 2. 配置文件组织
```
src/main/resources/
├── dev/
│   └── application.yml
├── test/
│   └── application.yml
├── prod/
│   └── application.yml
└── mapper/
    └── *.xml
```

### 3. 配置类管理
- **配置类位置**: 统一在 `service-base` 模块
- **自动配置**: 使用 `@EnableAutoConfiguration` 自动加载
- **条件配置**: 使用 `@ConditionalOnProperty` 条件配置
- **配置验证**: 使用 `@Validated` 进行配置验证

## 🚀 部署架构规范

### 1. 容器化部署
- **Docker化**: 每个服务打包为 Docker 镜像
- **镜像管理**: 统一的镜像命名和版本管理
- **健康检查**: 配置服务健康检查
- **资源限制**: 设置合理的资源限制

### 2. 服务编排
- **Docker Compose**: 开发环境使用 Docker Compose
- **Kubernetes**: 生产环境使用 K8s 编排
- **服务网格**: 考虑使用 Istio 服务网格
- **监控告警**: 集成 Prometheus + Grafana

### 3. 高可用设计
- **多实例部署**: 关键服务多实例部署
- **负载均衡**: 使用 Nginx 或 K8s Service
- **故障转移**: 配置故障自动转移
- **数据备份**: 定期备份重要数据

## 📊 监控和运维

### 1. 监控体系
- **应用监控**: 使用 Spring Boot Actuator
- **链路追踪**: 集成 Zipkin 或 Jaeger
- **日志管理**: 使用 ELK 或 Loki 管理日志
- **性能监控**: 监控服务响应时间和吞吐量

### 2. 运维规范
- **自动化部署**: CI/CD 流水线自动化部署
- **蓝绿部署**: 支持蓝绿部署和滚动更新
- **回滚机制**: 快速回滚到稳定版本
- **容量规划**: 根据业务增长规划容量

## 🔒 安全设计规范

### 1. 认证授权
- **JWT认证**: 使用 JWT 进行无状态认证
- **权限控制**: 基于角色的权限控制
- **API安全**: API 接口安全防护
- **数据加密**: 敏感数据加密存储

### 2. 网络安全
- **HTTPS**: 生产环境强制使用 HTTPS
- **防火墙**: 配置网络防火墙规则
- **VPN访问**: 内网服务通过 VPN 访问
- **安全审计**: 记录安全相关操作日志

## 📈 扩展性设计

### 1. 水平扩展
- **无状态设计**: 服务设计为无状态
- **数据分片**: 数据库水平分片
- **缓存策略**: 使用 Redis 进行缓存(非必要不启用,保留最低限度)
- **CDN加速**: 静态资源使用 CDN

### 2. 垂直扩展
- **资源优化**: 合理配置 CPU 和内存
- **数据库优化**: 数据库性能优化
- **代码优化**: 代码性能优化
- **架构优化**: 架构层面的性能优化

## 🚫 禁止事项

### 严格禁止
1. **循环依赖** - 服务间不允许循环依赖
2. **硬编码配置** - 不允许硬编码敏感配置
3. **单点故障** - 关键服务不允许单点故障
4. **直接数据库访问** - 跨服务不允许直接访问数据库

### 不推荐
1. **过度拆分** - 避免服务过度拆分
2. **同步调用链过长** - 避免同步调用链过长
3. **共享数据库** - 避免多个服务共享数据库
4. **紧耦合设计** - 避免服务间紧耦合

## ✅ 推荐事项

### 最佳实践
1. **服务自治** - 每个服务独立开发和部署
2. **API优先** - 先设计API接口再实现
3. **配置外部化** - 配置信息外部化管理
4. **监控先行** - 先搭建监控再部署服务
5. **渐进式迁移** - 逐步迁移到微服务架构

### 设计模式
1. **API网关模式** - 统一入口和路由
2. **服务发现模式** - 动态服务发现
3. **熔断器模式** - 防止服务雪崩
4. **配置中心模式** - 集中配置管理
5. **分布式追踪模式** - 链路追踪

---

**版本**: v1.0  
**创建日期**: 2025-08-04  
**最后更新**: 2025-08-04  
**维护者**: scccy 